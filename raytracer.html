<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>title</title>
  </head>
  <body>
    <canvas id="scene" width="600" height="600" style="border: 1px solid black" />
    <script>
     // https://www.gabrielgambetta.com/computer-graphics-from-scratch/basic-ray-tracing.html#fnref1
     const canvas = document.getElementById("scene");
     const viewport = {
       width: 1,
       height: 1,
       depth: 1
     };
     const ctx = canvas.getContext("2d");
     const origin = [0, 0, 0];
     const backgroundColor = [255, 255, 255];
     const scene = {
       lights: [
         {
           type: 'ambient',
           intensity: 0.2
         },
         {
           type: 'point',
           intensity: 0.6,
           position: [2, 1, 0]
         },
         {
           type: 'directional',
           intensity: 0.2,
           direction: [1, 4, 4]
         },
       ],
       spheres: [
         {
           center: [0, -1, 3],
           radius: 1,
           color: [255, 0, 0],
           specular: 500,
         },
         {
           center: [2, 0, 4],
           radius: 1,
           color: [0, 0, 255],
           specular: 500,
         },
         {
           center: [-2, 0, 4],
           radius: 1,
           color: [0, 255, 0],
           specular: 10,
         },
         {
           center: [0, -5001, 0],
           radius: 5000,
           color: [255, 255, 0],
           specular: 1000,
         },
         {
           center: [0, 2, 6],
           radius: 1,
           color: [255, 0, 255],
           specular: -1,
         },
       ]
     };

     function add(V1, V2) {
       return V1.map((val, i) => val + V2[i]);
     }

     function dot(V1, V2) {
       return sum(V1.map((val, i) => val * V2[i]));
     }

     function len(V) {
       return Math.sqrt(dot(V, V));
     }

     function scale(s, V) {
       return V.map(val => val * s);
     }

     function sub(V1, V2) {
       return V1.map((val, i) => val - V2[i]);
     }

     function sum(V) {
       return V.reduce((acc, val) => acc + val, 0);
     }

     function putPixel(x, y, [r, g, b, a = 255]) {
       // Change coordinates from canvas, where the origin is at the top left,
       // to viewport coordinates, where the origin is at the center
       x = canvas.width / 2 + x;
       y = canvas.height / 2 - y;
       ctx.fillStyle = `rgba(${r},${g},${b},${a})`;
       ctx.fillRect(x, y, 1, 1);
     }

     function canvasToViewport(x, y) {
       x = x * (viewport.width / canvas.width);
       y = y * (viewport.height / canvas.height);
       return [x, y, viewport.depth];
     }

     function computeLighting(P, N, V, s) {
       let i = 0;
       for (let light of scene.lights) {
         if (light.type === 'ambient') {
           i += light.intensity;
         } else {
           let L = light.type === 'point' ? sub(light.position, P) : light.direction

           // Diffuse
           // cos(a) of two vectors is the dot product divided by the product of the lengths
           let nDotL = dot(N, L);
           if (nDotL > 0) {
             i += light.intensity * nDotL / (len(N) * len(L));
           }

           // Specular
           // L = vector to the light source
           // R = reflection of L, across the normal
           // L = Lp + Ln
           // Lp = component of L perpendicular to N
           // Ln = component of L tangent to N
           // Ln = N*ln, N being the normal unit vector, and ln a scalar
           // ln = <N,L>
           // Ln = N<N,L>, projection of L onto N
           // Lp = L - Ln = L - N<N,L>
           // R = N<N,L> - L + N<N,L>
           // R = 2N<N,L> - L
           // cos(a)^s is used to model specularity, see note on cos above
           if (s !== -1) {
             let R = sub(scale(2 * dot(N, L), N), L);
             let rDotV = dot(R, V);
             if (rDotV > 0) {
               i += light.intensity * Math.pow(rDotV/(len(R) * len(V)), s);
             }
           }
         }
       }
       return i;
     }

     function intersectRaySphere(O, D, sphere) {
       // P = point on sphere, C = center
       // O = origin
       // D = V - O, vector from origin to point on the viewport, used for the "ray"
       // Equation for sphere
       // <P-C, P-C> = r^2
       // Equation for a ray from origin to point on the sphere
       // P = O + tD
       // Essentially substitute P in the first with the second equation,
       // and then rearrange so it solves for 0 and use the quadratic formula
       // <O + tD - C, O + tD - C> = r^2
       // <OC + tD, OC + tD> = r^2
       // Dot product is distributive, so:
       // <OC, OC> + <tD, OC> + <OC, tD> + <tD, tD> = r^2
       // <tD, tD> + 2<tD, OC> + <OC, OC> = r^2
       // t^2<D, D> + t*2<OC, D> + <OC, OC> = r^2
       // t^2<D, D> + t*2<OC, D> + <OC, OC> - r^2 = 0
       // k1 = <D, D>
       // k2 = 2<OC, D>
       // k3 = <OC, OC> - r^2
       // k1*t^2 + k2*t + k3 = 0
       let { center, radius } = sphere;
       let OC = sub(origin, center);
       let k1 = dot(D, D);
       let k2 = 2 * dot(OC, D);
       let k3 = dot(OC, OC) - radius ** 2;
       let discriminant = Math.sqrt(k2 ** 2 - 4 * k1 * k3);
       let denominator = 2 * k1;
       return [
         (-k2 + discriminant) / denominator,
         (-k2 - discriminant) / denominator,
       ];
     }

     function traceRay(O, D, tMin, tMax) {
       let closestT = Infinity;
       let closestSphere = null;
       for (let sphere of scene.spheres) {
         let [t1, t2] = intersectRaySphere(O, D, sphere);
         if (t1 >= tMin && t1 <= tMax && t1 < closestT) {
           closestT = t1;
           closestSphere = sphere;
         }
         if (t2 >= tMin && t2 <= tMax && t2 < closestT) {
           closestT = t2;
           closestSphere = sphere;
         }
       }
       if (closestSphere) {
         let P = add(O, scale(closestT, D)); // P = O + tD
         let N = sub(P, closestSphere.center); // normal at point
         N = scale(1/len(N), N); // convert to unit vector
         let V = D.map(v => -v); // reverse of direction is reflection to the viewport
         return scale(computeLighting(P, N, V, closestSphere.specular), closestSphere.color);
       }
       return backgroundColor;
     }

     function render() {
       const hw = Math.floor(canvas.width / 2);
       const hh = Math.floor(canvas.height / 2);
       for (let x = -hw; x < hw; x++) {
         for (let y = -hh; y < hh; y++) {
           const direction = canvasToViewport(x, y);
           const color = traceRay(origin, direction, 1, Infinity);
           putPixel(x, y, color);
         }
       }
     }

     render();
    </script>
  </body>
</html>
