<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>title</title>
  </head>
  <body>
    <canvas id="scene" width="600" height="600" style="border: 1px solid black" />
    <script>
     // https://www.gabrielgambetta.com/computer-graphics-from-scratch/basic-ray-tracing.html#fnref1
     const canvas = document.getElementById("scene");
     const viewport = {
       width: 1,
       height: 1,
       depth: 1
     };
     const ctx = canvas.getContext("2d");
     const origin = [0, 0, 0];
     const backgroundColor = [255, 255, 255];
     const scene = {
       lights: [
         {
           type: 'ambient',
           intensity: 0.2
         },
         {
           type: 'point',
           intensity: 0.6,
           position: [2, 1, 0]
         },
         {
           type: 'directional',
           intensity: 0.2,
           direction: [1, 4, 4]
         },
       ],
       spheres: [
         {
           center: [0, -1, 3],
           radius: 1,
           color: [255, 0, 0]
         },
         {
           center: [2, 0, 4],
           radius: 1,
           color: [0, 0, 255]
         },
         {
           center: [-2, 0, 4],
           radius: 1,
           color: [0, 255, 0]
         },
         {
           center: [0, -5001, 0],
           radius: 5000,
           color: [255, 255, 0]
         },
         {
           center: [0, 2, 6],
           radius: 1,
           color: [255, 0, 255]
         },
       ]
     };

     function add(v1, v2) {
       return v1.map((val, i) => val + v2[i]);
     }

     function dot(v1, v2) {
       return sum(v1.map((val, i) => val * v2[i]));
     }

     function len(v) {
       return Math.sqrt(dot(v, v));
     }

     function scale(s, v) {
       return v.map(val => val * s);
     }

     function sub(v1, v2) {
       return v1.map((val, i) => val - v2[i]);
     }

     function sum(v) {
       return v.reduce((acc, val) => acc + val, 0);
     }

     function putPixel(x, y, [r, g, b, a = 255]) {
       // Change coordinates from canvas, where the origin is at the top left,
       // to viewport coordinates, where the origin is at the center
       x = canvas.width / 2 + x;
       y = canvas.height / 2 - y;
       ctx.fillStyle = `rgba(${r},${g},${b},${a})`;
       ctx.fillRect(x, y, 1, 1);
     }

     function canvasToViewport(x, y) {
       x = x * (viewport.width / canvas.width);
       y = y * (viewport.height / canvas.height);
       return [x, y, viewport.depth];
     }

     function computeLighting(p, n) {
       let i = 0;
       for (let light of scene.lights) {
         if (light.type === 'ambient') {
           i += light.intensity;
         } else {
           let l = light.type === 'point' ? sub(light.position, p) : light.direction
           // cos a of two vectors is the dot product divided by the product of the lengths
           let nDotL = dot(n, l);
           if (nDotL > 0) {
             i += light.intensity * nDotL / (len(n) * len(l));
           }
         }
       }
       return i;
     }

     function intersectRaySphere(o, d, sphere) {
       // P = point on sphere, C = center
       // O = origin
       // D = V - O, vector from origin to point on the viewport, used for the "ray"
       // Equation for sphere
       // <P-C, P-C> = r^2
       // Equation for a ray from origin to point on the sphere
       // P = O + tD
       // Essentially substitute P in the first with the second equation,
       // and then rearrange so it solves for 0 and use the quadratic formula
       // <O + tD - C, O + tD - C> = r^2
       // <OC + tD, OC + tD> = r^2
       // Dot product is distributive, so:
       // <OC, OC> + <tD, OC> + <OC, tD> + <tD, tD> = r^2
       // <tD, tD> + 2<tD, OC> + <OC, OC> = r^2
       // t^2<D, D> + t*2<OC, D> + <OC, OC> = r^2
       // t^2<D, D> + t*2<OC, D> + <OC, OC> - r^2 = 0
       // k1 = <D, D>
       // k2 = 2<OC, D>
       // k3 = <OC, OC> - r^2
       // k1*t^2 + k2*t + k3 = 0
       let { center, radius } = sphere;
       let oc = sub(origin, center);
       let k1 = dot(d, d);
       let k2 = 2 * dot(oc, d);
       let k3 = dot(oc, oc) - radius ** 2;
       let discriminant = Math.sqrt(k2 ** 2 - 4 * k1 * k3);
       let denominator = 2 * k1;
       return [
         (-k2 + discriminant) / denominator,
         (-k2 - discriminant) / denominator,
       ];
     }

     function traceRay(o, d, tMin, tMax) {
       let closestT = Infinity;
       let closestSphere = null;
       for (let sphere of scene.spheres) {
         let [t1, t2] = intersectRaySphere(o, d, sphere);
         if (t1 >= tMin && t1 <= tMax && t1 < closestT) {
           closestT = t1;
           closestSphere = sphere;
         }
         if (t2 >= tMin && t2 <= tMax && t2 < closestT) {
           closestT = t2;
           closestSphere = sphere;
         }
       }
       if (closestSphere) {
         let p = add(o, scale(closestT, d)); // P = O + tD
         let n = sub(p, closestSphere.center); // normal at point
         n = scale(1/len(n), n); // convert to unit vector
         return scale(computeLighting(p, n), closestSphere.color);
       }
       return backgroundColor;
     }

     function render() {
       const hw = Math.floor(canvas.width / 2);
       const hh = Math.floor(canvas.height / 2);
       for (let x = -hw; x < hw; x++) {
         for (let y = -hh; y < hh; y++) {
           const direction = canvasToViewport(x, y);
           const color = traceRay(origin, direction, 1, Infinity);
           putPixel(x, y, color);
         }
       }
     }

     render();
    </script>
  </body>
</html>
